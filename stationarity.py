# -*- coding: utf-8 -*-
"""Stationarity

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sc-YlHd9QvC0nite6pEl9oWZD64e5VYu
"""

from IPython import get_ipython
get_ipython().run_line_magic('matplotlib', 'inline')
!pip install statsmodels yfinance
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
import statsmodels.api as sm # Import for correlogram plot
import warnings
warnings.filterwarnings("ignore")

# Set the date range starting from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-04-08"  # Up to current date (April 08, 2025)

# Fetch stock data for NVDA, AAPL, and TSLA with auto_adjust=False
stocks = ['NVDA', 'AAPL', 'TSLA']
data = yf.download(stocks, start=start_date, end=end_date, auto_adjust=False)['Adj Close']

# Function to simulate a random walk based on stock returns
def simulate_random_walk(price_series, steps):
    returns = price_series.pct_change().dropna()
    random_steps = np.random.choice([-1, 1], size=steps) * returns.std()
    random_walk = np.cumsum(random_steps) + price_series.iloc[0]
    return random_walk

# Function to perform unit root test (ADF test)
def unit_root_test(series, stock_name):
    result = adfuller(series.dropna())
    print(f"\nUnit Root Test (ADF) for {stock_name}:")
    print(f"ADF Statistic: {result[0]:.4f}")
    print(f"p-value: {result[1]:.4f}")
    print("Critical Values:", {k: f"{v:.4f}" for k, v in result[4].items()})
    if result[1] < 0.05:
        print(f"{stock_name} is likely stationary (reject null hypothesis).")
    else:
        print(f"{stock_name} is likely non-stationary (fail to reject null hypothesis).")

# Function to fit ARMA model and forecast
def fit_arma_model(series, stock_name, order=(1, 0, 1)):
    model = ARIMA(series.dropna(), order=order)
    fitted_model = model.fit()
    print(f"\nARMA(1,0,1) Model Summary for {stock_name}:")
    print(fitted_model.summary().tables[1])  # Coefficients table
    forecast = fitted_model.forecast(steps=10)
    return forecast

# Plotting function (modified to include correlogram plot)
def plot_results(stock_name, original_series, random_walk, forecast):
    fig, axes = plt.subplots(4, 1, figsize=(12, 12))  # Increased figure size, using subplots

    # Original Price Series
    axes[0].plot(original_series, label=f"{stock_name} Price", color='blue')
    axes[0].set_title(f"{stock_name} Stock Price")
    axes[0].legend()

    # Random Walk
    axes[1].plot(random_walk, label="Random Walk", color='orange')
    axes[1].set_title(f"{stock_name} Random Walk Simulation")
    axes[1].legend()

    # ARMA Forecast
    axes[2].plot(original_series[-50:], label=f"{stock_name} Price (Last 50 Days)", color='blue')
    axes[2].plot(range(len(original_series) - 1, len(original_series) + len(forecast)),
                 np.concatenate([original_series[-1:], forecast]),
                 label="ARMA Forecast", color='green')
    axes[2].set_title(f"{stock_name} ARMA Forecast")
    axes[2].legend()

    # Correlogram Plot (Added)
    sm.graphics.tsa.plot_pacf(original_series, lags=30, ax=axes[3], title=f"{stock_name} Correlogram")

    plt.tight_layout()
    plt.show()

# Analyze each stock
for stock in stocks:
    print(f"\n=== Analysis for {stock} ===")

    # 1. Random Walk Simulation
    rw_simulation = simulate_random_walk(data[stock], len(data[stock]))

    # 2. Unit Root Test
    unit_root_test(data[stock], stock)

    # 3. ARMA Model (using first differences to ensure stationarity)
    diff_series = data[stock].diff().dropna()  # First differences
    forecast = fit_arma_model(diff_series, stock)

    # 4. Plot Results
    plot_results(stock, data[stock], rw_simulation, forecast)